### Алгоритм проверки кода на плагиат
В файле "Readme.md" были кратко освещены основные шаги алгоритма. Дадим их подробное описание:
1) Генерализация кода 
1.1) Замена названий всех функций на F
1.2) Исключение комментариев из документа
1.3) Исключение всех переносов, строк, пробелов и отступов
1.4) Все строковые константы заменяются на str, а символьные - на chr
1.5) Исключение всех имен переменных
1.6) Все целочисленные типы заменяются на int
1.7) Все типы чисел с плавающей точкой заменяются на float
1.8) Остальные типы заменяюися на type.
Сложность этого алгоритма - O(n), где n - число символов в файле (нам предстоит единожды пройти по всему файлу)
2) Поиск отпечатков
2.1) Пусть h - длина "окна", а k - длина подстроки, для которой вычисляется hash. Мы используем метод просеивания, поэтому необходим параметр h.
2.1) hash(x) - функция, которая выдает одни и те же значения на одинаковых наборах входных данных, причем эти значения равномерно распределены на числовой оси.
2.2) Нас интересуют подпоследовательности символов длины k. Очевидно, что для документа длины l всего будут существовать w = l - k + 1 таких подпоследовательностей. В изученной литературе рекомендовано пользоваться алгоритмом кольцевого хэша для вычисления последовательности значений hash(x). Сложность вычисления хэша подстроки из k сиволов- O(1), следовательно, для всего документа- O(l - k). 
Функция для подсчета значений в кольцевом хэшэ находится в директории formula
2.3) В каждом "окне" - последовательности значений hash- функций длины h- выбирается минимальное, причем это минимальное не должно повторять выбранное в предыдущем окне значение.В противном случае такое значение просто не включается в отпечаток. Так вычисляется отпечаток документа. На каждом шаге выбор минимального осуществляется за O(h). Всего шагов - (l-k+1-h+1). Следовательно, сложность этой операции O((l-k-h)*h). 
3) Сравнение отпечатков документов
3.1) Сортируем набор хэшэй за O(n*logn) и O(m* logm), а затем вычисляем повторяющиеся значения хэшэй СЛИЯНИЕМ ОТСОРТИРОВАННЫХ СПИСКОВ (очень полезная для меня задача, с которойя я плохо справилась на РК) - за O(n+m)). Cуществуют формулы, определяющие степень присутствия и отсутсвия документа в документе. Они лежат в директории formula. (формулы вычисления присутствия и маскимального присутствия)
3.2) Итак. все документы просканированы, все максимальные присутствия вычислены. Теперь отсеиваем те документы,которые, на наш взгляд, показали ошибочное совпадение (например, 0.3 и ниже). 
4) Поиск совпадений
4.1) Находим в документе позиции совпадающих хэшэй
4.2) проверяем хэши на границах совпадающий областей и при необходимости расширяем эти области
4.3) Записываем позиции плагиата
Вообще говоря, сразу же возникает вопрос: действительно ли нам необходимо выполнять этот процесс поиска позиции, или можно ограничиться задачей до пункта 4?