### Алгоритм проверки кода на плагиат
В файле "Readme.md" были кратко освещены основные шаги алгоритма. Дадим их подробное описание:
1) Генерализация кода 
* Замена названий всех функций на F
* Исключение комментариев из документа
* Исключение всех переносов, строк, пробелов и отступов
* Все строковые константы заменяются на str, а символьные - на chr
* Исключение всех имен переменных
* Все целочисленные типы заменяются на int
* Все типы чисел с плавающей точкой заменяются на float
* Остальные типы заменяюися на type.
Сложность этого алгоритма - O(n), где n - число символов в файле (нам предстоит единожды пройти по всему файлу)
2) Поиск отпечатков
* Пусть h - длина "окна", а k - длина подстроки, для которой вычисляется hash. Мы используем метод просеивания, поэтому необходим параметр h.
* hash(x) - функция, которая выдает одни и те же значения на одинаковых наборах входных данных, причем эти значения равномерно распределены на числовой оси.
* Нас интересуют подпоследовательности символов длины k. Очевидно, что для документа длины l всего будут существовать w = l - k + 1 таких подпоследовательностей. В изученной литературе рекомендовано пользоваться алгоритмом кольцевого хэша для вычисления последовательности значений hash(x). Сложность вычисления хэша подстроки из k сиволов- O(1), следовательно, для всего документа- O(l - k). 
Функция для подсчета значений в кольцевом хэшэ находится в директории formula
* В каждом "окне" - последовательности значений hash- функций длины h- выбирается минимальное, причем это минимальное не должно повторять выбранное в предыдущем окне значение.В противном случае такое значение просто не включается в отпечаток. Так вычисляется отпечаток документа. На каждом шаге выбор минимального осуществляется за O(h). Всего шагов - (l-k+1-h+1). Следовательно, сложность этой операции O((l-k-h)*h). 
3) Сравнение отпечатков документов
* Сортируем набор хэшэй за O(n*logn) и O(m* logm), а затем вычисляем повторяющиеся значения хэшэй СЛИЯНИЕМ ОТСОРТИРОВАННЫХ СПИСКОВ (очень полезная для меня задача, с которойя я плохо справилась на РК) - за O(n+m)). Cуществуют формулы, определяющие степень присутствия и отсутсвия документа в документе. Они лежат в директории formula. (формулы вычисления присутствия и маскимального присутствия)
* Итак. все документы просканированы, все максимальные присутствия вычислены. Теперь отсеиваем те документы,которые, на наш взгляд, показали ошибочное совпадение (например, 0.3 и ниже). 
4) Поиск совпадений
* Находим в документе позиции совпадающих хэшэй
* проверяем хэши на границах совпадающий областей и при необходимости расширяем эти области
* Записываем позиции плагиата
Вообще говоря, сразу же возникает вопрос: действительно ли нам необходимо выполнять этот процесс поиска позиции, или можно ограничиться задачей до пункта 4?
