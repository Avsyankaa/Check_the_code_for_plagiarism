# Алгоритм жадного строкового замощения
### Вход - две строки A и B над допустимым алфавитом (токенизированные).
### Выход - НЕПЕРЕСЕКАЮЩИЙСЯ набор их СОВПАДАЮЩИХ подстрок (тайлов).
Таким образом, верно определив метрику, после получения результата работы алгоритма мы можем дать ответ на вопрос о наличии палгиата (а также о степени его присутствия) в кодах программ. 
## Дополнительные определения
1)  MinimumMatchLengt - минимальная длина совпадающих подстрок P и T, которая учитывается алгоритмом.
2) Maxmatch- длина наибольшего совпадение на данной итерации алгоритма.
3) Matches - кандидаты на попадание в набор тайлов.
## Основные шаги алгоритма
Вначале все элементы не помечены.
1) Среди всех непомеченных элементов ищем наиблее длинную совпадающую подстроку. 
2) Если 
	а) найденная подстрока > maxmatch
		Удаляем из matches все подстроки, которые там были, и 		помещаем туда найденную подстроку.
	b) найденная подстрока = maxmatch
		Добавляем найденную подстроку в список.
	c) найденная подстрока < maxmatch
		Всё остается по-прежнему.
3) Проходим по списку matches. Если элемент matches не содержит помеченных элементов, то помещаем его в тайлы, а также помечаем элементы, из которых он состоит. Если длины строк в списке больше, чем MinimumMAtchLength, то возвращаемся к этапу номер 1. Поскольку меньшие тайлы не появляются раньше больших, то для проверки элемента matches на помеченные символы можно проверять не каждый элемент, а только те, что находятся на концах. Эту проверку можно осуществить за O(1). 
Итак, оценим сложность этого алгоритма. Самой "страшной" является операция, описанная в пункте 1: она состоит из трех вложенных циклов, первый из которых пробегается по первой токенизированной строке, второй - по второй, а третий - находит наибольшее возможное совпадение(подстроку). Асимптотическая сложность этого алгоритма - O(n^3), где n-> 0-0(бесконечность) - длина токенизированной строки. Оказывается, на практике это значение намного  меньше -  O(n^2). Существуют также многочисленные улучшения этого алгоритма, которые позволяют уменьшить константу, однако асимптотика остается прежней (например, алгоритм Карпа- Рабина).
Основные недостатки:
Ложноположительные срабатывания
Если мы разбиваем украденный код на блоки путем замены или вставки операторов, код которых(блоков) в токенизированном предсталении меньше, чем MinimumMAtchLength, то детектор не срабатывает
Если задать слишком большую константу MinimumMAtchLength, то можно упустить плагиат, а если слишком маленькую - вызвать false positive => выбор этой константы затруднителен
